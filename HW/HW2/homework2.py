# -*- coding: utf-8 -*-
"""Homework2_stub.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-0spgc1FGMnYffakV8mRqnqvu3wbUA7E
"""

import numpy as np
import urllib
import scipy.optimize
import random
from sklearn import linear_model
import gzip
from collections import defaultdict

import warnings
warnings.filterwarnings("ignore")

def assertFloat(x):
    assert type(float(x)) == float

def assertFloatList(items, N):
    assert len(items) == N
    assert [type(float(x)) for x in items] == [float]*N

f = open("5year.arff", 'r')

# Read and parse the data
while not '@data' in f.readline():
    pass

dataset = []
for l in f:
    if '?' in l: # Missing entry
        continue
    l = l.split(',')
    values = [1] + [float(x) for x in l]
    values[-1] = values[-1] > 0 # Convert to bool
    dataset.append(values)

print(dataset[0])
X = [d[:-1] for d in dataset]
y = [d[-1] for d in dataset]

answers = {} # Your answers

def accuracy(predictions, y):
  y = np.array(y)
  return (predictions == y).sum() / len(y)

def BER(predictions, y):
  y = np.array(y)
  tn = ((predictions == 0) & (y == 0)).sum()
  fn = ((predictions == 0) & (y == 1)).sum()
  tp = ((predictions == 1) & (y == 1)).sum()
  fp = ((predictions == 1) & (y == 0)).sum()
  return (fn / (tp + fn) + fp / (tn + fp)) / 2

### Question 1

mod = linear_model.LogisticRegression(C=1)
mod.fit(X,y)

pred = mod.predict(X)

acc1 = accuracy(pred, y)
ber1 = BER(pred, y)
print(acc1, ber1)
answers['Q1'] = [acc1, ber1] # Accuracy and balanced error rate

assertFloatList(answers['Q1'], 2)

### Question 2

mod = linear_model.LogisticRegression(C=1, class_weight='balanced')
mod.fit(X,y)

pred = mod.predict(X)



acc2 = accuracy(pred, y)
ber2 = BER(pred, y)
print(acc2, ber2)
answers['Q2'] = [acc2, ber2]

assertFloatList(answers['Q2'], 2)

### Question 3

random.seed(3)
random.shuffle(dataset)

X = [d[:-1] for d in dataset]
y = [d[-1] for d in dataset]

Xtrain, Xvalid, Xtest = X[:len(X)//2], X[len(X)//2:(3*len(X))//4], X[(3*len(X))//4:]
ytrain, yvalid, ytest = y[:len(X)//2], y[len(X)//2:(3*len(X))//4], y[(3*len(X))//4:]

mod = linear_model.LogisticRegression(C=1, class_weight='balanced')
mod.fit(Xtrain,ytrain)

len(Xtrain), len(Xvalid), len(Xtest)

predtrain = mod.predict(Xtrain)
predvalid = mod.predict(Xvalid)
predtest = mod.predict(Xtest)
berTrain = BER(predtrain, ytrain)
berValid = BER(predvalid, yvalid)
berTest = BER(predtest, ytest)
print(berTrain, berValid, berTest)

answers['Q3'] = [berTrain, berValid, berTest]

assertFloatList(answers['Q3'], 3)

### Question 4

C_values = [10**i for i in range(-4,5)]
berList = []
for c in C_values:
  mod = linear_model.LogisticRegression(C=c, class_weight='balanced')
  mod.fit(Xtrain,ytrain)
  predvalid = mod.predict(Xvalid)
  berValid = BER(predvalid, yvalid)
  berList.append(berValid)

print(berList)
answers['Q4'] = berList

assertFloatList(answers['Q4'], 9)

### Question 5

bestC = C_values[berList.index(min(berList))]
ber5 = min(berList)
print(bestC, ber5)

answers['Q5'] = [bestC, ber5]

assertFloatList(answers['Q5'], 2)

### Question 6

f = gzip.open("young_adult_10000.json.gz")
dataset = []
for l in f:
    dataset.append(eval(l))

dataTrain = dataset[:9000]
dataTest = dataset[9000:]
print(dataTrain[0])



# Some data structures you might want

usersPerItem = defaultdict(set) # Maps an item to the users who rated it
itemsPerUser = defaultdict(set) # Maps a user to the items that they rated
reviewsPerUser = defaultdict(list)
reviewsPerItem = defaultdict(list)
ratingDict = {} # To retrieve a rating for a specific user/item pair

for d in dataTrain:
  user, item, rating = d['user_id'], d['book_id'], d['rating']
  usersPerItem[item].add(user)
  itemsPerUser[user].add(item)
  ratingDict[(user, item)] = rating

def Jaccard(s1, s2):
  intersection = len(s1.intersection(s2))
  union = len(s1.union(s2))
  return intersection / union if union != 0 else 0

def mostSimilar(i, N):
  sim = []
  users = usersPerItem[i]
  for item in usersPerItem:
    if item == i: continue
    s = Jaccard(users, usersPerItem[item])
    sim.append((s,item))
  sim.sort(reverse=True)
  return sim[:N]

answers['Q6'] = mostSimilar('2767052', 10)
print(answers['Q6'])

assert len(answers['Q6']) == 10
assertFloatList([x[0] for x in answers['Q6']], 10)

### Question 7

Rbars = {}
for item in usersPerItem:
  users = usersPerItem[item]
  Rbars[item] = np.mean([ratingDict[(user, item)] for user in users])

def predictRating(user, item):
  if item not in Rbars:
    return np.mean(list(Rbars.values()))

  numerator=0.0
  denominator=0.0
  js = itemsPerUser[user] - {item}
  for j in js:
    numerator += (ratingDict[(user, j)] - Rbars[j]) * Jaccard(usersPerItem[item], usersPerItem[j])
    denominator += Jaccard(usersPerItem[item], usersPerItem[j])

  if denominator == 0:
    return Rbars[item]

  return Rbars[item] + numerator / denominator

testset = [(d['user_id'], d['book_id'], d['rating']) for d in dataTest]

def computeMSE(testset):
  mse = 0.0
  for t in testset:
    user, item, rating = t
    pred = predictRating(user, item)
    mse += (rating - pred) ** 2
  return mse / len(testset)

mse7 = computeMSE(testset)
print(mse7)
answers['Q7'] = mse7

assertFloat(answers['Q7'])

### Question 8

Rbars2 = {}
for user in itemsPerUser:
  items = itemsPerUser[user]
  Rbars2[user] = np.mean([ratingDict[(user, item)] for item in items])

def predictRating2(user, item):
  if user not in Rbars2:
    return np.mean(list(Rbars2.values()))

  numerator=0.0
  denominator=0.0
  js = usersPerItem[item] - {user}
  for j in js:
    numerator += (ratingDict[(j, item)] - Rbars2[j]) * Jaccard(itemsPerUser[user], itemsPerUser[j])
    denominator += Jaccard(itemsPerUser[user], itemsPerUser[j])

  if denominator == 0:
    return Rbars2[user]

  return Rbars2[user] + numerator / denominator

def computeMSE2(testset):
  mse = 0.0
  for t in testset:
    user, item, rating = t
    pred = predictRating2(user, item)
    mse += (rating - pred) ** 2
  return mse / len(testset)

mse8 = computeMSE2(testset)
print(mse8)
answers['Q8'] = mse8

assertFloat(answers['Q8'])

f = open("answers_hw2.txt", 'w')
f.write(str(answers) + '\n')
f.close()

