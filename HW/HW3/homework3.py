# -*- coding: utf-8 -*-
"""Homework3_stub.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OeJT1dMCrK956ZVb9c-mpjQ6LhWqROFG
"""

import gzip
from collections import defaultdict
import math
import scipy.optimize
from sklearn import svm
import numpy as np
import string
import random
import string
from sklearn import linear_model

import warnings
warnings.filterwarnings("ignore")

def assertFloat(x):
    assert type(float(x)) == float

def assertFloatList(items, N):
    assert len(items) == N
    assert [type(float(x)) for x in items] == [float]*N

def readGz(path):
    for l in gzip.open(path, 'rt'):
        yield eval(l)

def readCSV(path):
    f = gzip.open(path, 'rt')
    f.readline()
    for l in f:
        u,b,r = l.strip().split(',')
        r = int(r)
        yield u,b,r

answers = {}

# Some data structures that will be useful
def acc(pred, y):
  return (np.array(pred)==np.array(y)).sum()/len(pred)

allRatings = []
for l in readCSV("train_Interactions.csv.gz"):
    allRatings.append(l)

len(allRatings)

random.seed(0)

ratingsTrain = allRatings[:190000]
ratingsValid = allRatings[190000:]
print(ratingsTrain[0])
ratingsPerUser = defaultdict(list)
ratingsPerItem = defaultdict(list)
usersPerItem = defaultdict(set)
itemsPerUser = defaultdict(set)
ratingDict = {}
for u,b,r in ratingsTrain:
    ratingsPerUser[u].append((b,r))
    ratingsPerItem[b].append((u,r))
    usersPerItem[b].add(u)
    itemsPerUser[u].add(b)
    ratingDict[(u,b)]=r

##################################################
# Read prediction                                #
##################################################
booksPerUser = {u: set(b for b, r in ratingsPerUser[u]) for u in ratingsPerUser}
Negative = []
avg_rating = np.mean([r for _,_,r in ratingsTrain])
all_books = set(ratingsPerItem.keys())

for u,b,r in ratingsValid:
  if u in booksPerUser:
    unread_books = list(all_books - booksPerUser[u])
    if unread_books:
      negative_book = random.choice(unread_books)
      Negative.append((u, negative_book, 0))

newRatingsValid = ratingsValid + Negative
print(len(newRatingsValid))

# Copied from baseline code
bookCount = defaultdict(int)
totalRead = 0

for user,book,_ in readCSV("train_Interactions.csv.gz"):
    bookCount[book] += 1
    totalRead += 1

mostPopular = [(bookCount[x], x) for x in bookCount]
mostPopular.sort()
mostPopular.reverse()
print(mostPopular)

return1 = set()
count = 0
for ic, i in mostPopular:
    count += ic
    return1.add(i)
    if count > totalRead/2: break

print(len(return1))

### Question 1

def predictRead(dataValid, popularSet):
  pred=[]
  y1=[]
  for u,b,r in dataValid:
    if b in popularSet:
      pred.append(1)
    else:
      pred.append(0)

    if r>0: y1.append(1)
    else: y1.append(0)

  acc1=acc(pred, y1)
  return acc1

acc1 = predictRead(newRatingsValid, return1)
print(acc1)
answers['Q1'] = acc1

assertFloat(answers['Q1'])

### Question 2

thre=np.linspace(0,1,30)
max_acc=0
res=[]

for t in thre:
  popular = set()
  count = 0
  for ic, i in mostPopular:
      count += ic
      popular.add(i)
      if count > totalRead * t: break

  acc_t = predictRead(newRatingsValid, popular)
  print(len(popular), t, acc_t)
  if acc_t > max_acc:
    res = [t, acc_t]
    max_acc = acc_t

print(res)
threshold, acc2 = res[0], res[1]
answers['Q2'] = [threshold, acc2]

assertFloat(answers['Q2'][0])
assertFloat(answers['Q2'][1])

### Question 3/4

for t in thre:
  popularMax = set()
  count = 0
  for ic, i in mostPopular:
      count += ic
      popularMax.add(i)
      if count > totalRead * 0.69: break

import matplotlib.pyplot as plt


def Jaccard(s1, s2):
  intersection = len(s1.intersection(s2))
  union = len(s1.union(s2))
  return intersection / union if union != 0 else 0

def cosine_similarity(s1, s2):
    if len(s1) == 0 or len(s2) == 0:
        return 0
    intersection = len(s1.intersection(s2))
    norm1 = np.sqrt(len(s1))
    norm2 = np.sqrt(len(s2))
    return intersection / (norm1 * norm2)

def predictRead_Jaccard(u, b, threshold):
  if u not in itemsPerUser or b not in usersPerItem:
      return 1 if b in popularMax else 0

  read = itemsPerUser[u] - {b}
  used = usersPerItem[b] - {u}
  max_sim_u = 0
  max_sim_i = 0

  for r in read:
    sim = Jaccard(usersPerItem[r], usersPerItem[b])
    max_sim_u = max(max_sim_u, sim)
  for r in used:
    sim = Jaccard(itemsPerUser[r], itemsPerUser[u])
    max_sim_i = max(max_sim_i, sim)
  #print(max_sim)
  return 1 if max_sim_u + 0.5 * max_sim_i > threshold else 0

def find_optimal_threshold(dataValid):
  thresholds = np.linspace(0, 0.1, 30)
  accs=[]
  max_acc = 0
  best_t = 0
  y = [1 if r>0 else 0 for _,_,r in dataValid]

  for t in thresholds:
    pred=[]
    for u,b,_ in dataValid:
      pred.append(predictRead_Jaccard(u,b,t))
    acc_t = acc(pred, y)
    accs.append(acc_t)
    if acc_t > max_acc:
      max_acc = acc_t
      best_t = t

  plt.figure(figsize=(8, 6))
  plt.plot(thresholds, accs, marker='o', linestyle='-')
  return max_acc, best_t


acc3,t3 = find_optimal_threshold(newRatingsValid)
print(acc3,t3)

def predictRead_combine(u, b, threshold):
  if u not in itemsPerUser or b not in usersPerItem:
      return 1 if b in popularMax else 0

  read = itemsPerUser[u] - {b}
  max_sim = 0
  for r in read:
    sim = Jaccard(usersPerItem[r], usersPerItem[b])
    max_sim = max(max_sim, sim)

  if b in popularMax:

    max_sim *= 1.5

  return 1 if max_sim > threshold else 0

def find_optimal_threshold_combine(dataValid):
  thresholds = np.linspace(0, 0.008, 30)
  accs=[]
  max_acc = 0
  best_t = 0
  y = [1 if r>0 else 0 for _,_,r in dataValid]

  for t in thresholds:
    pred=[]
    for u,b,_ in dataValid:
      pred.append(predictRead_combine(u,b,t))
    acc_t = acc(pred, y)
    accs.append(acc_t)
    if acc_t > max_acc:
      max_acc = acc_t
      best_t = t

  plt.figure(figsize=(8, 6))
  plt.plot(thresholds, accs, marker='o', linestyle='-')
  return max_acc, best_t


acc4,t4 = find_optimal_threshold_combine(newRatingsValid)
print(acc4,t4)

answers['Q3'] = acc3
answers['Q4'] = acc4

assertFloat(answers['Q3'])
assertFloat(answers['Q4'])

predictions = open("predictions_Read.csv", 'w')
for l in open("pairs_Read.csv"):
    if l.startswith("userID"):
        predictions.write(l)
        continue
    u,b = l.strip().split(',')
    pred=predictRead_combine(u,b,t4)
    predictions.write(f"{u},{b},{pred}\n")
    # (etc.)

predictions.close()

answers['Q5'] = "I confirm that I have uploaded an assignment submission to gradescope"

assert type(answers['Q5']) == str

##################################################
# Rating prediction                              #
##################################################

from collections import defaultdict
import torch

len_train = len(ratingsTrain)

def mse(data, alpha, beta_u, beta_i):
  sse = 0
  l=len(data)
  for u,b,r in data:
    sse += (alpha + beta_u[u] + beta_i[i] - r) ** 2
  mse = sse / l
  return mse

def train(epoch, lam=1, plot=True):
  alpha = np.mean([r for _,_,r in ratingsTrain])
  beta_u = defaultdict(float)
  beta_i = defaultdict(float)
  min_mse = 100
  best_para = None

  mses = []
  for e in range(epoch):
    alpha_numerator = sum(r-(beta_u[u]+beta_i[i]) for u,i,r in ratingsTrain)
    alpha = alpha_numerator / len_train

    for u in itemsPerUser:
      beta_u_numerator = sum(ratingDict[(u,i)]-(alpha+beta_i[i]) for i in itemsPerUser[u])
      beta_u[u] = beta_u_numerator / (lam + len(itemsPerUser[u]))

    for i in usersPerItem:
      beta_i_numerator = sum(ratingDict[(u,i)]-(alpha+beta_u[u]) for u in usersPerItem[i])
      beta_i[i] = beta_i_numerator / (lam + len(usersPerItem[i]))

    msemse = mse(ratingsValid, alpha, beta_u, beta_i)
    if msemse < min_mse:
      best_para=(alpha, beta_u, beta_i)
      min_mse = msemse
    #print(msemse)
    mses.append(msemse)

  if plot:
    plt.figure(figsize=(8, 6))
    plt.plot(list(range(epoch)), mses, marker='o', linestyle='-')

  return best_para, min_mse


def train2(epoch, lam=1, plot=True):
  alpha = np.mean([r for _,_,r in ratingsTrain])
  beta_u = defaultdict(float)
  beta_i = defaultdict(float)
  min_mse = 100
  best_para = None
  learning_rate = 0.01

  mses = []
  for e in range(epoch):
    for u, i, r in ratingsTrain:
        pred = alpha + beta_u[u] + beta_i[i]
        error = r - pred

        alpha += learning_rate * (error)
        beta_u[u] += learning_rate * (error - lam * beta_u[u])
        beta_i[i] += learning_rate * (error - lam * beta_i[i])


    msemse = mse(ratingsValid, alpha, beta_u, beta_i)
    if msemse < min_mse:
      best_para=(alpha, beta_u, beta_i)
      min_mse = msemse
    #print(msemse)
    mses.append(msemse)

  if plot:
    plt.figure(figsize=(8, 6))
    plt.plot(list(range(epoch)), mses, marker='o', linestyle='-')

  return best_para, min_mse

### Question 6

bestpara, validMSE = train(epoch=40)
print(validMSE)

answers['Q6'] = validMSE

assertFloat(answers['Q6'])

### Question 7

alpha, beta_u, beta_i = bestpara
maxUser = max(beta_u, key=beta_u.get)
maxBeta = beta_u[maxUser]
minUser = min(beta_u, key=beta_u.get)
minBeta = beta_u[minUser]

print(maxUser, minUser, maxBeta, minBeta)
answers['Q7'] = [maxUser, minUser, maxBeta, minBeta]

assert [type(x) for x in answers['Q7']] == [str, str, float, float]

### Question 8

lambdas = [0.01, 0.1, 0.5, 1, 5, 10, 100]
mse_ls=[]
paras=[]

for l in lambdas:
  para, mse_l = train(epoch=50, lam=l, plot=False)
  mse_ls.append(mse_l)
  paras.append(para)


plt.figure(figsize=(8, 6))
plt.plot(lambdas, mse_ls, marker='o', linestyle='-')

lamb, validMSE = lambdas[mse_ls.index(min(mse_ls))], min(mse_ls)
best_para_l = paras[mse_ls.index(min(mse_ls))]
print(lamb, validMSE)
answers['Q8'] = (lamb, validMSE)

assertFloat(answers['Q8'][0])
assertFloat(answers['Q8'][1])

a, bu, bi = best_para_l

predictions = open("predictions_Rating.csv", 'w')
for l in open("pairs_Rating.csv"):
    if l.startswith("userID"): # header
        predictions.write(l)
        continue
    u,b = l.strip().split(',') # Read the user and item from the "pairs" file and write out your prediction
    pred = a + bu[u] + bi[i]
    predictions.write(f"{u},{b},{pred}\n")
    # (etc.)

predictions.close()

f = open("answers_hw3.txt", 'w')
f.write(str(answers) + '\n')
f.close()

